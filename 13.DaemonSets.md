### **Section D: Advanced Kubernetes Concepts**

---

#### **13. DaemonSets**

DaemonSets are a crucial part of Kubernetes for managing and deploying system-level workloads that need to run on every node within a cluster. This section delves into the intricacies of DaemonSets, their use cases, and how to deploy them with practical code examples.

##### **13.a. Understanding DaemonSets**

- **What is a DaemonSet?**
  - A DaemonSet ensures that a copy of a specific Pod runs on all, or a selection of, nodes in a Kubernetes cluster.
  - Unlike Deployments or StatefulSets that focus on scaling application instances, DaemonSets are geared towards system-level operations, such as monitoring or logging agents, which need to run on every node.
  - **Key Characteristics:**
    - Pods managed by a DaemonSet are automatically added to nodes when they are created and removed when nodes are deleted.
    - They ensure that the Pods are always running on the desired nodes without manual intervention.

- **How DaemonSets Work:**
  - When a DaemonSet is created, Kubernetes ensures that the specified Pod is scheduled on all nodes that match the DaemonSet’s configuration.
  - If a new node is added to the cluster, the DaemonSet automatically schedules the Pod on this new node.
  - If a node is removed, the Pod is terminated.

- **Daemons and Node Labels:**
  - DaemonSets can be configured to run Pods only on nodes with specific labels. This allows targeting of certain nodes, such as those with specific hardware or geographic location, for system-level operations.

##### **13.b. Use Cases for DaemonSets**

DaemonSets are primarily used for cluster-wide services and system-level workloads. Here are some common use cases:

- **Logging and Monitoring Agents:**
  - Deploying agents that collect logs (e.g., Fluentd, Logstash) or monitoring metrics (e.g., Prometheus Node Exporter, Datadog) from all nodes.
  - **Example:** Ensuring that each node is monitored by Prometheus by deploying Node Exporter as a DaemonSet.
  
- **Networking and Security:**
  - Running network proxies, CNI (Container Network Interface) plugins, or security agents that need to be present on every node.
  - **Example:** Deploying a CNI plugin like Calico or Weave for network policies.

- **System Upgrades and Maintenance:**
  - Rolling out system updates, such as kernel modules or OS patches, by deploying a Pod that performs the necessary upgrades.
  - **Example:** Using DaemonSets to ensure that all nodes receive a security patch by running a maintenance script.

- **Storage Management:**
  - Managing distributed storage solutions that require agents running on each node for tasks like storage orchestration or persistent volume management.
  - **Example:** Deploying a Ceph or GlusterFS storage daemon on all storage nodes.

##### **13.c. Code Sample: Deploying System-Level DaemonSets**

Here is a step-by-step guide to deploying a simple DaemonSet that runs a logging agent on every node in a Kubernetes cluster.

- **1. Define the DaemonSet Configuration:**
  ```yaml
  apiVersion: apps/v1
  kind: DaemonSet
  metadata:
    name: fluentd
    labels:
      app: fluentd
  spec:
    selector:
      matchLabels:
        name: fluentd
    template:
      metadata:
        labels:
          name: fluentd
      spec:
        containers:
        - name: fluentd
          image: fluent/fluentd:latest
          resources:
            limits:
              memory: "200Mi"
              cpu: "100m"
          volumeMounts:
            - name: varlog
              mountPath: /var/log
        volumes:
          - name: varlog
            hostPath:
              path: /var/log
  ```

- **Explanation:**
  - **metadata:** Defines the name and labels for the DaemonSet.
  - **spec.selector:** Ensures that the Pods created by this DaemonSet are properly managed.
  - **spec.template:** Defines the Pod template that will be deployed on each node.
    - **containers:** Specifies the container image to be used, in this case, Fluentd for log aggregation.
    - **volumeMounts:** Mounts the host’s `/var/log` directory into the container to collect logs.
    - **volumes:** Uses a `hostPath` volume to access the host’s file system.

- **2. Deploy the DaemonSet:**
  ```sh
  kubectl apply -f fluentd-daemonset.yaml
  ```

- **3. Verify the DaemonSet:**
  ```sh
  kubectl get daemonsets
  ```

- **4. Check the Pods on Each Node:**
  ```sh
  kubectl get pods -o wide
  ```

- **5. Updating a DaemonSet:**
  - To update a DaemonSet, modify the YAML file and apply it again. Kubernetes will perform a rolling update, ensuring minimal disruption.
  ```sh
  kubectl apply -f fluentd-daemonset.yaml
  ```

- **6. Clean Up the DaemonSet:**
  - If you need to remove the DaemonSet, simply delete it using the following command:
  ```sh
  kubectl delete daemonset fluentd
  ```

---

These notes provide a thorough understanding of DaemonSets in Kubernetes, including their architecture, use cases, and practical deployment examples. By mastering DaemonSets, you'll be equipped to manage cluster-wide system-level tasks effectively.
