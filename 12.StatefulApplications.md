### **Section C: Core Kubernetes Concepts**

---

#### **12. Stateful Applications**

Stateful applications require persistent storage and stable network identities to ensure that data is retained and accessible across Pod restarts. Kubernetes addresses this need with StatefulSets, which provide the necessary framework for managing stateful workloads.

##### **12.a. Deploying Stateful Applications with StatefulSets**

- **Understanding StatefulSets:**
  - **Definition:**
    - A StatefulSet is a Kubernetes workload API object used to manage stateful applications. Unlike Deployments, StatefulSets maintain sticky identities for each of their Pods.
  - **Key Features:**
    - **Stable, Unique Pod Names:** Pods in a StatefulSet are given a stable identifier that persists across rescheduling.
    - **Ordered Deployment and Scaling:** Pods are created, updated, and deleted in a strict order.
    - **Persistent Storage:** StatefulSets work seamlessly with Persistent Volumes to ensure data is not lost during Pod rescheduling.

- **StatefulSet Use Cases:**
  - **Databases:** Systems like MySQL, MongoDB, or PostgreSQL that require persistent data and stable network identities.
  - **Distributed Systems:** Applications like Kafka or Cassandra, where the order and state of each node are crucial.

- **Example Configuration of a StatefulSet:**
  ```yaml
  apiVersion: apps/v1
  kind: StatefulSet
  metadata:
    name: mysql
  spec:
    serviceName: "mysql"
    replicas: 3
    selector:
      matchLabels:
        app: mysql
    template:
      metadata:
        labels:
          app: mysql
      spec:
        containers:
        - name: mysql
          image: mysql:5.7
          env:
          - name: MYSQL_ROOT_PASSWORD
            value: "my-secret-pw"
          ports:
          - containerPort: 3306
            name: mysql
          volumeMounts:
          - name: mysql-persistent-storage
            mountPath: /var/lib/mysql
    volumeClaimTemplates:
    - metadata:
        name: mysql-persistent-storage
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 1Gi
  ```

- **Explanation:**
  - **Service Name:** StatefulSet requires a Service that governs its Pods.
  - **Replicas:** Number of Pods to be maintained.
  - **VolumeClaimTemplates:** Each Pod gets its own Persistent Volume Claim, ensuring that data remains consistent across Pod restarts.

##### **12.b. Scaling StatefulSets**

- **Scaling Up and Down:**
  - **Scaling Up:**
    - When you scale a StatefulSet up, new Pods are created sequentially, maintaining their ordered identities. For example, scaling from 3 to 5 replicas would result in Pods being created as `mysql-3`, `mysql-4`, and so on.
  - **Scaling Down:**
    - When scaling down, the Pods are terminated in reverse order. For example, scaling down from 5 to 3 replicas would result in the termination of `mysql-4` and `mysql-3`.

- **Commands for Scaling:**
  - **Scaling Up:**
    ```sh
    kubectl scale statefulset mysql --replicas=5
    ```
  - **Scaling Down:**
    ```sh
    kubectl scale statefulset mysql --replicas=3
    ```

- **Considerations for Scaling:**
  - **Data Consistency:** Ensure that the data is correctly replicated and consistent across nodes before scaling.
  - **Application-Specific Logic:** Some applications may require additional steps before scaling, such as moving data or rebalancing.

##### **12.c. Managing Persistent Data with StatefulSets**

- **Data Persistence:**
  - **Persistent Volume Claims (PVCs):**
    - Each Pod in a StatefulSet gets its own PVC, ensuring that the data stored is consistent and unique to that Pod. This is crucial for databases and other stateful workloads.
  - **Reclaim Policies:**
    - The reclaim policy for Persistent Volumes used by StatefulSets is typically `Retain`, which ensures that data is not deleted when a Pod is terminated.

- **Handling Failures:**
  - **Pod Failures:**
    - When a Pod fails, it is recreated with the same identity and accesses the same Persistent Volume. This guarantees that the data remains intact.
  - **Node Failures:**
    - In case of node failures, Kubernetes reschedules the Pod on a different node, attaching the same Persistent Volume, ensuring data availability.

- **Backup and Restore Strategies:**
  - **Regular Backups:**
    - For critical applications, regularly back up the Persistent Volumes to prevent data loss.
  - **Restore Procedures:**
    - Implement robust restore procedures to recover data in case of corruption or data loss.

##### **12.d. Code Sample: Deploying a Stateful Application**

- **Deploying a MySQL StatefulSet:**

  **1. Define a Headless Service for StatefulSet:**
  ```yaml
  apiVersion: v1
  kind: Service
  metadata:
    name: mysql
  spec:
    ports:
    - port: 3306
      name: mysql
    clusterIP: None
    selector:
      app: mysql
  ```

  **2. Define the StatefulSet:**
  ```yaml
  apiVersion: apps/v1
  kind: StatefulSet
  metadata:
    name: mysql
  spec:
    serviceName: "mysql"
    replicas: 3
    selector:
      matchLabels:
        app: mysql
    template:
      metadata:
        labels:
          app: mysql
      spec:
        containers:
        - name: mysql
          image: mysql:5.7
          env:
          - name: MYSQL_ROOT_PASSWORD
            value: "my-secret-pw"
          ports:
          - containerPort: 3306
            name: mysql
          volumeMounts:
          - name: mysql-persistent-storage
            mountPath: /var/lib/mysql
    volumeClaimTemplates:
    - metadata:
        name: mysql-persistent-storage
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 1Gi
  ```

  **3. Deploy the StatefulSet:**
  ```sh
  kubectl apply -f mysql-statefulset.yaml
  ```

  **4. Verify the StatefulSet and Pods:**
  ```sh
  kubectl get statefulsets
  kubectl get pods -l app=mysql
  ```

  **5. Scale the StatefulSet:**
  ```sh
  kubectl scale statefulset mysql --replicas=5
  ```

  **6. Verify the Scaling Operation:**
  ```sh
  kubectl get statefulsets
  kubectl get pods -l app=mysql
  ```

---

These notes provide a comprehensive understanding of deploying and managing stateful applications using StatefulSets in Kubernetes. The examples and code samples illustrate how to maintain persistent data and manage stateful workloads effectively.
